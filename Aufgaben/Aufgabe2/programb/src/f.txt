fn solve(lowest:i32, lowest_second:HashSet<i32>, mut all_slices:HashMap::<[i32;2], i32>, test_number:i32, n:i64) {
    let mut start_slices: Vec<[i32;2]> = Vec::new();   // change all_slices to mut 
    for (key, value) in all_slices.iter() {
        if *value >= lowest && (lowest_second.contains(&key[0]) || lowest_second.contains(&key[1])){
            start_slices.push(key.clone());
        }
    }
    let mut found_solution:bool = false;
    while !start_slices.is_empty() {
        let start: [i32;2] = start_slices.pop().unwrap();
        let mut x:i32 = start[0];
        let mut y:i32 = start[1];
        let mut z:i32 = lowest;
        modify_hash_map(&mut all_slices, start, -lowest); //t
        let mut stack: Vec<i32> = Vec::new();
        let mut step_backward:bool = false;
        order(&mut x, &mut y, &mut z);
        let mut state:i32;
        let mut success:bool = true;
        while !all_slices.is_empty() || step_backward { //t
            if step_backward {
                order(&mut x, &mut y, &mut z);
                if stack.is_empty() {
                    success = false;
                    break;
                }
                state = stack.pop().unwrap();
                let slice = back_backtrack(state, &mut x, &mut y, &mut z);
                modify_hash_map(&mut all_slices, slice, 1); //t
                if state == 3 {
                    continue;
                } else {
                    step_backward = false;
                }
            } else {
                state = 0;
            }
            order(&mut x, &mut y, &mut z);
            let arr:[bool;3] = [
                all_slices.contains_key(&[x, y]), //t
                all_slices.contains_key(&[x, z]), //t
                all_slices.contains_key(&[y, z]), //t
            ];
            if state == 0 {
                if !arr[0] {
                    if !arr[1] {
                        if !arr[2] {
                            step_backward = true;
                            continue;
                        } else {
                            stack.push(3);
                            x += 1;
                            modify_hash_map(&mut all_slices, [y,z], -1); //t
                        }
                    } else {
                        stack.push(2);
                        y += 1;
                        modify_hash_map(&mut all_slices, [x,z], -1); //t
                    }
                } else {
                    stack.push(1);
                    z += 1;
                    modify_hash_map(&mut all_slices, [x,y], -1); //t
                }
            } else if state == 1 {
                if !arr[1] {
                    if !arr[2] {
                        step_backward = true;
                        continue;
                    } else {
                        stack.push(3);
                        x += 1;
                        modify_hash_map(&mut all_slices, [y,z], -1); //t
                    }
                } else {
                    stack.push(2);
                    y += 1;
                    modify_hash_map(&mut all_slices, [x,z], -1); //t
                }
            } else {
                if !arr[2] {
                    step_backward = true;
                    continue;
                } else {
                    stack.push(3);
                    x += 1;
                    modify_hash_map(&mut all_slices, [y,z], -1); //t
                } 
            }
        }
        if success {
            output_rev(stack, start, lowest, test_number);
            found_solution = true;
            break;
        } else {
            modify_hash_map(&mut all_slices, start, lowest); //t delet
        }
    }
} 
